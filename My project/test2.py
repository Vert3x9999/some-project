# -*- coding: utf-8 -*-
"""test2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s_vlR65XXDhZwarzc_9RfAExtjXbMj4R
"""

import numpy as np
import random
import matplotlib.pyplot as plt

#以隨機點座標產生地圖
def random_map(n,bound,min_cost,max_cost):
  map = np.zeros((n,n+2))
  for i in range(n):
    #座標
    for j in range(2):
      map[i][j] = random.randint(0,bound)
    #花費
    for j in range(n):
      if j > i:
        map[i][j+2] = random.randint(min_cost,max_cost)
      elif j < i:
        map[i][j+2] = map[j][i+2]
  return map

#計算點與點之間的正規劃路徑
def calculate(bound,cost_range,n,map,weight):
  max_distance = bound * np.sqrt(2)
  distance = np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      distance[i][j] = np.linalg.norm(map[i,:2]-map[j,:2])
  cost = np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      if i != j:
        cost[i][j] = max(map[i][j+2]-min(cost_range),0)/(max(cost_range)-min(cost_range))
  normalize = (distance / max_distance * weight + cost * (1-weight))*100
  return np.round(normalize,3), np.round(distance,3)

#建構TSP路徑 回傳下一個節點
def TSP(current,visited,distance,tau,alpha,beta):
  propability = []
  for i in range(len(distance)):
    if i not in visited:
      a = tau[current][i] ** alpha
      b = (1 / max(distance[current][i],1e-6)) ** beta
      propability.append(a * b)
    else:
      propability.append(0)

  propability /= sum(propability)

  #亂跑
  if random.random() < 0.02:
    return random.choice([i for i in range(len(distance))if i not in visited])
  else:
    return np.random.choice(range(len(distance)),p=propability)

#更新費洛蒙
def update_pheromone(pheromone,path,path_L,Q,rho):
  pheromone *= rho
  for path,path_L in zip(path,path_L):
    for i in range(len(path)-1):
      a,b = path[i],path[i+1]
      pheromone[a][b] += Q/path_L
      pheromone[b][a] += Q/path_L
  return pheromone

#輸出
def print_out(t,S,n_cities,path,path_L,best_L,best_path,map):
    print("-"*50)
    print(f"Iter{t+1}:\nPath:  ")
    #for i in range(0,S,int(25/n_cities)):
      #print(f"{(path[i:i+int(25/n_cities)])}\n")
    print(f"Scores:{np.round(path_L,4)}\nBest_Score:{best_L}\nBest_path:{best_path}\n")

#主程式

def ACO(map,cost_range,weight,rho,S,alpha,beta,iter,Q):
  print(f"座標：\n{map[:,:2]}\n花費：\n{map[:,2:]}")

  #正規劃路徑
  normalize,distance = calculate(np.max(map[:,:2]),cost_range,len(map),map,weight)
  print(f"距離：\n{distance}\n正規劃路徑：\n{normalize}")

  #設定費洛蒙
  pheromone = np.ones(normalize.shape)/(len(normalize)*normalize[0,:].sum())

  best_path = None
  best_L = float("inf")
  L_list = []
  iter_list = []

  for t in range(iter):

    #調整alpha及beta
    alpha[0] = alpha[1]+(alpha[2]-alpha[1])*(t/iter)
    beta[0] = beta[1]+(beta[2]-beta[1])*(t/iter)
    round(alpha[0],8)
    round(beta[0],8)

    path = []
    path_L = []
    for i in range(S):

      #初使節點
      visited = []
      current = random.randint(0,len(normalize)-1)
      visited.append(current)

      #尋找下一節點
      while len(visited) < len(normalize):
        next = TSP(current,visited,normalize,pheromone,alpha[0],beta[0])
        visited.append(next)
        current = next

      visited.append(visited[0])
      path.append(visited)
      #if (t % 100 == 0)and(i == 1):
        #print(visited)

      #計算路徑長
      l = 0
      for j in range(len(visited)-1):
        l += normalize[visited[j]][visited[j+1]]
      path_L.append(l)

    #更新費洛蒙 及 最佳路徑
    pheromone = update_pheromone(pheromone,path,path_L,Q,rho)
    shortest_path = min(zip(path,path_L),key = lambda x:x[1])
    iter_list.append(shortest_path[1])

    if shortest_path[1] < best_L:
      best_path, best_L = shortest_path
    L_list.append(best_L)

    if ((t+1)%100 == 0) or (t == 0):
      print_out(t,S,len(normalize),path,path_L,best_L,best_path,map)

  #輸出結果
  total_cost = 0
  total_distance = 0
  for i in range(len(best_path)-1):
    total_cost += map[best_path[i]][best_path[i+1]+2]
    total_distance += distance[best_path[i]][best_path[i+1]]
  print(f"\nBest Path:{best_path}\nBest Score:{best_L}\nTotal Cost：{total_cost}, Total Distance：{total_distance}")

  #產生圖片
  plt.figure(figsize=(10, 6))
  plt.plot(range(1, iter + 1), L_list, label="Best Score (All Time)", linestyle="-", color="blue")
  plt.scatter(range(1, iter + 1), iter_list, label="Best Score (Per Iteration)", color="red", s=10)
  plt.xlabel("Iterations")
  plt.ylabel("Score")
  plt.title("ACO: Fitness Over Iterations")
  plt.legend()
  plt.grid()
  plt.show()

  return best_path,best_L

#前二位為座標 其後則為點之間的旅行花費
map = np.array([
    [3,5,0,2,3,4,5],
    [6,3,2,0,9,3,5],
    [2,1,3,9,0,1,4],
    [8,6,4,3,1,0,6],
    [6,7,5,5,4,6,0]
])
print(f"座標:\n{map[:,:2]}")#座標
print(f"花費:\n{map[:,2:]}")#花費

#隨機地圖
map = random_map(
    n = 10,
    bound = 30,
    min_cost = 50,
    max_cost = 100
)
map

ACO(
    map = map,
    cost_range = (50,100),
    weight =0.5,#對距離之權重
    rho = 0.7,
    S = 5,
    alpha = [0,1,2],#[當前alpha,初始alpha,最終alpha]
    beta = [0,5,3],#[當前beta,初期beta,最終beta]
    iter = 200,
    Q = 100
)

#匯入CSV檔
import pandas as pd
data = pd.read_csv('ACO_data.csv')
map = data.values

map

ACO(
    map = map,
    cost_range = (30,100),
    weight =0.8,
    rho = 0.7,
    S = 8,
    alpha = [0,1,2],#[當前alpha,初始alpha,最終alpha]
    beta = [0,5,3],#[當前beta,初期beta,最終beta]
    iter = 200,
    Q = 100
)